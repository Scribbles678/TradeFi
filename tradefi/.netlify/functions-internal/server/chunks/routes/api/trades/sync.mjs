import{d as e,a as t}from"../../../_/nitro.mjs";import{g as s,a as n,s as o,d as r,b as a}from"../../../_/supabase.mjs";import{createHmac as i}from"node:crypto";import"node:http";import"node:https";import"node:events";import"node:buffer";import"@iconify/utils";import"consola";import"node:url";import"ipx";import"node:fs";import"node:path";import"@supabase/supabase-js";const c=e((async e=>{var c,l;const p=t();try{console.log("Trade Sync: Starting sync process...");const e=p.asterApiKey,t=p.asterApiSecret,d=p.oandaApiKey,_=p.oandaBaseUrl,u=p.oandaAccountId,y=new Map,m=[];try{const s="https://fapi.asterdex.com",n="/fapi/v4/account",o=`timestamp=${Date.now().toString()}`,r=i("sha256",t).update(o).digest("hex"),a=await $fetch(`${s}${n}?${o}&signature=${r}`,{method:"GET",headers:{"X-MBX-APIKEY":e,"Content-Type":"application/json"}}),c=((null==a?void 0:a.positions)||[]).filter((e=>{const t=(e.symbol||"").toUpperCase(),s=t.includes("_")&&t.match(/^[A-Z]{3}_[A-Z]{3}$/),n=t.includes("/")&&t.match(/^[A-Z]{3}\/[A-Z]{3}$/);return 0!==parseFloat(e.positionAmt)&&!s&&!n}));c.forEach((e=>{const t=`aster_${e.symbol}_${e.positionSide}`,s=Math.abs(parseFloat(e.positionAmt)),n=parseFloat(e.entryPrice),o=parseFloat(e.markPrice),r=Math.abs(parseFloat(e.notional)),a=parseFloat(e.unrealizedProfit),i=r>0?a/r*100:0;y.set(t,{symbol:e.symbol,exchange:"aster",asset_class:"crypto",entry_price:n,current_price:o,quantity:s,position_size_usd:r,unrealized_pnl_usd:a,unrealized_pnl_percent:i,side:parseFloat(e.positionAmt)>0?"BUY":"SELL"})})),console.log("Trade Sync: Found",c.length,"current Aster DEX positions")}catch(e){console.error("Trade Sync: Error fetching Aster DEX positions:",e)}try{if(u&&d&&_){const e=_.endsWith("/")?_.slice(0,-1):_,t=await $fetch(`${e}/v3/accounts/${u}/openPositions`,{method:"GET",headers:{Authorization:`Bearer ${d}`,"Content-Type":"application/json"}}),s=(null==t?void 0:t.positions)||[];s.forEach((e=>{var t,s,n,o,r,a;const i=parseFloat((null==(t=e.long)?void 0:t.units)||"0"),c=parseFloat((null==(s=e.short)?void 0:s.units)||"0"),l=i>0,p=l?i:Math.abs(c),d=parseFloat(l?(null==(n=e.long)?void 0:n.averagePrice)||"0":(null==(o=e.short)?void 0:o.averagePrice)||"0"),_=parseFloat(l?(null==(r=e.long)?void 0:r.unrealizedPL)||"0":(null==(a=e.short)?void 0:a.unrealizedPL)||"0"),u=Math.abs(p*d),m=u>0?_/u*100:0;let g=d;try{p>0&&d>0&&(g=l?d+_/p:d-_/p)}catch(e){}const h=`oanda_${e.instrument}_${l?"LONG":"SHORT"}`;y.set(h,{symbol:e.instrument,exchange:"oanda",asset_class:"forex",entry_price:d,current_price:g,quantity:p,position_size_usd:u,unrealized_pnl_usd:_,unrealized_pnl_percent:m,side:l?"BUY":"SELL"})})),console.log("Trade Sync: Found",s.length,"current OANDA positions")}}catch(e){console.error("Trade Sync: Error fetching OANDA positions:",e)}console.log("Trade Sync: Saving current positions to Supabase...");const g=new Map;for(const[e,t]of y.entries())try{const r=(await s(t.asset_class)).find((e=>e.symbol===t.symbol&&e.exchange===t.exchange&&e.side===t.side));if(r)await n(r.id,{current_price:t.current_price,unrealized_pnl_usd:t.unrealized_pnl_usd,unrealized_pnl_percent:t.unrealized_pnl_percent,quantity:t.quantity,position_size_usd:t.position_size_usd,updated_at:(new Date).toISOString()}),g.set(e,r);else{const s=await o({symbol:t.symbol,side:t.side,asset_class:t.asset_class,exchange:t.exchange,entry_price:t.entry_price,entry_time:(new Date).toISOString(),quantity:t.quantity,position_size_usd:t.position_size_usd,current_price:t.current_price,unrealized_pnl_usd:t.unrealized_pnl_usd,unrealized_pnl_percent:t.unrealized_pnl_percent});s&&g.set(e,s)}}catch(e){console.error("Trade Sync: Error saving position to Supabase:",e)}const h=await s();console.log("Trade Sync: Found",h.length,"positions in Supabase");const f=await r(1e3),S=new Set(f.map((e=>`${e.exchange||"unknown"}_${e.symbol}_${e.entry_time}`)));console.log("Trade Sync: Found",f.length,"existing trades in database");for(const e of h){if(!e.exchange||!e.symbol)continue;const t="BUY"===e.side?"LONG":"SHORT",s=`${e.exchange.toLowerCase()}_${e.symbol}_${t}`;if(!y.has(s)){const t=`${e.exchange}_${e.symbol}_${e.entry_time}`;if(S.has(t))console.log("Trade Sync: Trade already exists for position:",e.symbol);else{const t=e.current_price||e.entry_price,s=e.entry_price,n=e.quantity||0,o=e.position_size_usd||0,r=null==(c=e.exchange)?void 0:c.toLowerCase(),a=null==(l=e.asset_class)?void 0:l.toLowerCase();let i=0,p=0;if("oanda"===r&&"forex"===a||"aster"===r&&"crypto"===a?(i=e.unrealized_pnl_usd||0,p=e.unrealized_pnl_percent||0,console.log(`Trade Sync: Using exchange-provided P&L for ${e.symbol} (${r}/${a}):`,{unrealized_pnl_usd:i,unrealized_pnl_percent:p})):s&&t&&n>0?(i="BUY"===e.side?(t-s)*n:(s-t)*n,o>0?p=i/o*100:s>0&&(p=(t-s)/s*100,"SELL"===e.side&&(p=-p)),console.log(`Trade Sync: Calculated P&L from prices for ${e.symbol}:`,{entry_price:s,exit_price:t,quantity:n,calculated_pnl_usd:i,calculated_pnl_percent:p})):(console.warn("Trade Sync: Using unrealized P&L as fallback for",e.symbol,"- entry/exit price calculation failed"),i=e.unrealized_pnl_usd||0,p=e.unrealized_pnl_percent||0),e.symbol&&s&&n>0){const c={symbol:e.symbol,side:e.side,asset_class:e.asset_class||("oanda"===e.exchange?"forex":"crypto"),exchange:e.exchange,entry_price:s,entry_time:e.entry_time,exit_price:t,exit_time:e.updated_at||(new Date).toISOString(),quantity:n,position_size_usd:o,stop_loss_price:e.stop_loss_price,take_profit_price:e.take_profit_price,stop_loss_percent:e.stop_loss_percent,take_profit_percent:e.take_profit_percent,pnl_usd:parseFloat(i.toFixed(2)),pnl_percent:parseFloat(p.toFixed(2)),is_winner:i>0,exit_reason:"Position closed (detected by sync)",notes:"Auto-synced from closed position"};m.push(c),console.log("Trade Sync: Found closed position:",e.symbol,{exchange:r,asset_class:a,entry_price:s,exit_price:t,quantity:n,pnl_usd:i,pnl_percent:p,side:e.side})}else console.log("Trade Sync: Skipping position without P&L data:",e.symbol)}}}if(m.length>0){console.log("Trade Sync: Saving",m.length,"closed trades...");const e=[];for(const t of m)try{const s=await a(t);s&&e.push(s)}catch(e){console.error("Trade Sync: Error saving trade:",e)}return{success:!0,message:`Synced ${e.length} closed trades`,trades:e,count:e.length}}return{success:!0,message:"No closed positions found",trades:[],count:0}}catch(e){return console.error("Trade Sync: Error:",e),{success:!1,error:e instanceof Error?e.message:String(e),message:"Error syncing trades"}}}));export{c as default};
//# sourceMappingURL=sync.mjs.map
